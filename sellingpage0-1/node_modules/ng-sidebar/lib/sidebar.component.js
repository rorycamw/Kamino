"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var sidebar_service_1 = require("./sidebar.service");
var utils_1 = require("./utils");
var Sidebar = (function () {
    function Sidebar(_sidebarService) {
        this._sidebarService = _sidebarService;
        // `openedChange` allows for "2-way" data binding
        this.opened = false;
        this.openedChange = new core_1.EventEmitter();
        this.mode = 'over';
        this.dockedSize = '0px';
        this.position = 'start';
        this.animate = true;
        this.trapFocus = true;
        this.autoFocus = true;
        this.showBackdrop = false;
        this.closeOnClickBackdrop = false;
        this.closeOnClickOutside = false;
        this.keyClose = false;
        this.keyCode = 27; // Default to ESC key
        this.onOpenStart = new core_1.EventEmitter();
        this.onOpened = new core_1.EventEmitter();
        this.onCloseStart = new core_1.EventEmitter();
        this.onClosed = new core_1.EventEmitter();
        this.onModeChange = new core_1.EventEmitter();
        this.onPositionChange = new core_1.EventEmitter();
        /** @internal */
        this._onRerender = new core_1.EventEmitter();
        this._focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]),' +
            'textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';
        this._clickEvent = 'click';
        this._onClickOutsideAttached = false;
        this._onKeyDownAttached = false;
        this._onResizeAttached = false;
        if (utils_1.isIOS() && 'ontouchstart' in window) {
            this._clickEvent = 'touchstart';
        }
        this._normalizePosition();
        this.open = this.open.bind(this);
        this.close = this.close.bind(this);
        this._onTransitionEnd = this._onTransitionEnd.bind(this);
        this._onFocusTrap = this._onFocusTrap.bind(this);
        this._onClickOutside = this._onClickOutside.bind(this);
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onResize = this._onResize.bind(this);
        this._openSub = this._sidebarService.onOpen(this.open);
        this._closeSub = this._sidebarService.onClose(this.close);
    }
    Sidebar.prototype.ngOnInit = function () {
        var _this = this;
        if (!utils_1.isBrowser()) {
            return;
        }
        // Prevents an initial transition hiccup in IE (issue #59)
        if (this.animate) {
            this.animate = false;
            setTimeout(function () {
                _this.animate = true;
            });
        }
    };
    Sidebar.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (!utils_1.isBrowser()) {
            return;
        }
        if (changes['opened']) {
            if (changes['opened'].currentValue) {
                this.open();
            }
            else {
                this.close();
            }
        }
        if (changes['closeOnClickOutside'] || changes['keyClose']) {
            this._initCloseListeners();
        }
        if (changes['position']) {
            // Handle "start" and "end" aliases
            this._normalizePosition();
            // Emit change in timeout to allow for position change to be rendered first
            setTimeout(function () {
                _this.onPositionChange.emit(changes['position'].currentValue);
            });
        }
        if (changes['mode']) {
            this.onModeChange.emit(changes['mode'].currentValue);
        }
        if (changes['autoCollapseHeight'] || changes['autoCollapseWidth']) {
            this._initCollapseListeners();
        }
    };
    Sidebar.prototype.ngOnDestroy = function () {
        if (!utils_1.isBrowser()) {
            return;
        }
        this._destroyCloseListeners();
        this._destroyCollapseListeners();
        this._openSub.unsubscribe();
        this._closeSub.unsubscribe();
    };
    // Sidebar toggling
    // ==============================================================================================
    /**
     * Opens the sidebar and emits the appropriate events.
     */
    Sidebar.prototype.open = function () {
        var _this = this;
        if (!utils_1.isBrowser()) {
            return;
        }
        this.opened = true;
        this.openedChange.emit(true);
        this.onOpenStart.emit();
        if (this.animate) {
            this._elSidebar.nativeElement.addEventListener('transitionend', this._onTransitionEnd);
        }
        else {
            this._setFocused();
            this._initCloseListeners();
            setTimeout(function () {
                if (_this.opened) {
                    _this.onOpened.emit();
                }
            });
        }
    };
    /**
     * Closes the sidebar and emits the appropriate events.
     */
    Sidebar.prototype.close = function () {
        var _this = this;
        if (!utils_1.isBrowser()) {
            return;
        }
        this.opened = false;
        this.openedChange.emit(false);
        this.onCloseStart.emit();
        if (this.animate) {
            this._elSidebar.nativeElement.addEventListener('transitionend', this._onTransitionEnd);
        }
        else {
            this._setFocused();
            this._destroyCloseListeners();
            setTimeout(function () {
                if (!_this.opened) {
                    _this.onClosed.emit();
                }
            });
        }
    };
    /**
     * Manually trigger a re-render of the container. Useful if the sidebar contents might change.
     */
    Sidebar.prototype.triggerRerender = function () {
        if (!utils_1.isBrowser()) {
            return;
        }
        this._onRerender.emit();
    };
    /**
     * @internal
     *
     * Computes the transform styles for the sidebar template.
     *
     * @return {CSSStyleDeclaration} The transform styles, with the WebKit-prefixed version as well.
     */
    Sidebar.prototype._getStyle = function () {
        var transformStyle = 'none';
        var marginStyle = {};
        var isSlideMode = this.mode === 'slide';
        if (!this.opened || isSlideMode) {
            transformStyle = "translate" + ((this.position === 'left' || this.position === 'right') ? 'X' : 'Y');
            var isLeftOrTop = this.position === 'left' || this.position === 'top';
            var isDockMode = this.mode === 'dock';
            var translateAmt = (isLeftOrTop ? '-' : '') + "100%";
            if (isDockMode && parseFloat(this.dockedSize) > 0) {
                var marginPos = "margin" + utils_1.upperCaseFirst(this.position);
                marginStyle = (_a = {},
                    _a[marginPos] = this.dockedSize,
                    _a);
            }
            transformStyle += "(" + translateAmt + ")";
        }
        return Object.assign(marginStyle, {
            webkitTransform: transformStyle,
            transform: transformStyle
        });
        var _a;
    };
    /**
     * @internal
     *
     * Handles the `transitionend` event on the sidebar to emit the onOpened/onClosed events after the transform
     * transition is completed.
     */
    Sidebar.prototype._onTransitionEnd = function (e) {
        if (e.target === this._elSidebar.nativeElement && e.propertyName.endsWith('transform')) {
            this._setFocused();
            if (this.opened) {
                this._initCloseListeners();
                this.onOpened.emit();
            }
            else {
                this._destroyCloseListeners();
                this.onClosed.emit();
            }
            this._elSidebar.nativeElement.removeEventListener('transitionend', this._onTransitionEnd);
        }
    };
    Object.defineProperty(Sidebar.prototype, "_shouldTrapFocus", {
        // Focus on open/close
        // ==============================================================================================
        /**
         * @internal
         *
         * Returns whether focus should be trapped within the sidebar.
         *
         * @return {boolean} Trap focus inside sidebar.
         */
        get: function () {
            return this.opened && this.trapFocus && this._isModeOver;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     *
     * Sets focus to the first focusable element inside the sidebar.
     */
    Sidebar.prototype._focusFirstItem = function () {
        if (this._focusableElements && this._focusableElements.length > 0) {
            this._focusableElements[0].focus();
        }
    };
    /**
     * @internal
     *
     * Loops focus back to the start of the sidebar if set to do so.
     */
    Sidebar.prototype._onFocusTrap = function (e) {
        if (this._shouldTrapFocus && !this._elSidebar.nativeElement.contains(e.target)) {
            this._focusFirstItem();
        }
    };
    /**
     * @internal
     *
     * Handles the ability to focus sidebar elements when it's open/closed to ensure that the sidebar is inert when
     * appropriate.
     */
    Sidebar.prototype._setFocused = function () {
        this._focusableElements = Array.from(this._elSidebar.nativeElement.querySelectorAll(this._focusableElementsString));
        if (this.opened) {
            this._focusedBeforeOpen = document.activeElement;
            // Restore focusability, with previous tabindex attributes
            for (var _i = 0, _a = this._focusableElements; _i < _a.length; _i++) {
                var el = _a[_i];
                var prevTabIndex = el.getAttribute('__tabindex__');
                if (prevTabIndex !== null) {
                    el.setAttribute('tabindex', prevTabIndex);
                    el.removeAttribute('__tabindex__');
                }
                else {
                    el.removeAttribute('tabindex');
                }
            }
            if (this.autoFocus) {
                this._focusFirstItem();
            }
            document.addEventListener('focus', this._onFocusTrap, true);
        }
        else {
            // Manually make all focusable elements unfocusable, saving existing tabindex attributes
            for (var _b = 0, _c = this._focusableElements; _b < _c.length; _b++) {
                var el = _c[_b];
                var existingTabIndex = el.getAttribute('tabindex');
                el.setAttribute('tabindex', '-1');
                if (existingTabIndex !== null) {
                    el.setAttribute('__tabindex__', existingTabIndex);
                }
            }
            document.removeEventListener('focus', this._onFocusTrap, true);
            // Set focus back to element before the sidebar was opened
            if (this.autoFocus && this._isModeOver && this._focusedBeforeOpen) {
                this._focusedBeforeOpen.focus();
            }
        }
    };
    // Close event handlers
    // ==============================================================================================
    /**
     * @internal
     *
     * Initializes event handlers for the closeOnClickOutside and keyClose options.
     */
    Sidebar.prototype._initCloseListeners = function () {
        var _this = this;
        if (this.opened && (this.closeOnClickOutside || this.keyClose)) {
            // In a timeout so that things render first
            setTimeout(function () {
                if (_this.closeOnClickOutside && !_this._onClickOutsideAttached) {
                    document.addEventListener(_this._clickEvent, _this._onClickOutside);
                    _this._onClickOutsideAttached = true;
                }
                if (_this.keyClose && !_this._onKeyDownAttached) {
                    document.addEventListener('keydown', _this._onKeyDown);
                    _this._onKeyDownAttached = true;
                }
            });
        }
    };
    /**
     * @internal
     *
     * Destroys the event handlers from _initCloseListeners.
     */
    Sidebar.prototype._destroyCloseListeners = function () {
        if (this._onClickOutsideAttached) {
            document.removeEventListener(this._clickEvent, this._onClickOutside);
            this._onClickOutsideAttached = false;
        }
        if (this._onKeyDownAttached) {
            document.removeEventListener('keydown', this._onKeyDown);
            this._onKeyDownAttached = false;
        }
    };
    /**
     * @internal
     *
     * Handles `click` events on anything while the sidebar is open for the closeOnClickOutside option.
     * Programatically closes the sidebar if a click occurs outside the sidebar.
     *
     * @param e {MouseEvent} Mouse click event.
     */
    Sidebar.prototype._onClickOutside = function (e) {
        if (this._onClickOutsideAttached && this._elSidebar && !this._elSidebar.nativeElement.contains(e.target)) {
            this.close();
        }
    };
    /**
     * @internal
     *
     * Handles the `keydown` event for the keyClose option.
     *
     * @param e {KeyboardEvent} Normalized keydown event.
     */
    Sidebar.prototype._onKeyDown = function (e) {
        e = e || window.event;
        if (e.keyCode === this.keyCode) {
            this.close();
        }
    };
    // Auto collapse handlers
    // ==============================================================================================
    /** @internal */
    Sidebar.prototype._initCollapseListeners = function () {
        var _this = this;
        if (this.autoCollapseHeight || this.autoCollapseWidth) {
            // In a timeout so that things render first
            setTimeout(function () {
                if (!_this._onResizeAttached) {
                    window.addEventListener('resize', _this._onResize);
                    _this._onResizeAttached = true;
                }
            });
        }
    };
    /** @internal */
    Sidebar.prototype._destroyCollapseListeners = function () {
        if (this._onResizeAttached) {
            window.removeEventListener('resize', this._onResize);
            this._onResizeAttached = false;
        }
    };
    /** @internal */
    Sidebar.prototype._onResize = function () {
        var winHeight = window.innerHeight;
        var winWidth = window.innerWidth;
        if (this.autoCollapseHeight) {
            if (winHeight <= this.autoCollapseHeight && this.opened) {
                this._wasCollapsed = true;
                this.close();
            }
            else if (winHeight > this.autoCollapseHeight && this._wasCollapsed) {
                this.open();
                this._wasCollapsed = false;
            }
        }
        if (this.autoCollapseWidth) {
            if (winWidth <= this.autoCollapseWidth && this.opened) {
                this._wasCollapsed = true;
                this.close();
            }
            else if (winWidth > this.autoCollapseWidth && this._wasCollapsed) {
                this.open();
                this._wasCollapsed = false;
            }
        }
    };
    Object.defineProperty(Sidebar.prototype, "_height", {
        // Helpers
        // ==============================================================================================
        /**
         * @internal
         *
         * Returns the rendered height of the sidebar (or the docked size).
         * This is used in the sidebar container.
         *
         * @return {number} Height of sidebar.
         */
        get: function () {
            if (this._elSidebar.nativeElement) {
                return this._isDocked ?
                    parseFloat(this.dockedSize) :
                    this._elSidebar.nativeElement.offsetHeight;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sidebar.prototype, "_width", {
        /**
         * @internal
         *
         * Returns the rendered width of the sidebar (or the docked size).
         * This is used in the sidebar container.
         *
         * @return {number} Width of sidebar.
         */
        get: function () {
            if (this._elSidebar.nativeElement) {
                return this._isDocked ?
                    parseFloat(this.dockedSize) :
                    this._elSidebar.nativeElement.offsetWidth;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sidebar.prototype, "_isDocked", {
        /**
         * @internal
         *
         * Returns whether the sidebar is "docked" -- i.e. it is closed but in dock mode.
         *
         * @return {boolean} Sidebar is docked.
         */
        get: function () {
            return this.mode === 'dock' && this.dockedSize && !this.opened;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sidebar.prototype, "_isModeOver", {
        /**
         * @internal
         *
         * Returns whether the sidebar is set to the default "over" mode.
         *
         * @return {boolean} Sidebar mode is "over".
         */
        get: function () {
            return this.mode === 'over';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     *
     * "Normalizes" position. For example, "start" would be "left" if the page is LTR.
     */
    Sidebar.prototype._normalizePosition = function () {
        var ltr = utils_1.isLTR();
        if (this.position === 'start') {
            this.position = ltr ? 'left' : 'right';
        }
        else if (this.position === 'end') {
            this.position = ltr ? 'right' : 'left';
        }
    };
    return Sidebar;
}());
Sidebar.decorators = [
    { type: core_1.Component, args: [{
                selector: 'ng-sidebar',
                template: "\n    <aside #sidebar\n      role=\"complementary\"\n      [attr.aria-hidden]=\"!opened\"\n      [attr.aria-label]=\"ariaLabel\"\n      class=\"ng-sidebar ng-sidebar--{{opened ? 'opened' : 'closed'}} ng-sidebar--{{position}} ng-sidebar--{{mode}}\"\n      [class.ng-sidebar--inert]=\"!opened && mode !== 'dock'\"\n      [class.ng-sidebar--animate]=\"animate\"\n      [ngClass]=\"sidebarClass\"\n      [ngStyle]=\"_getStyle()\">\n      <ng-content></ng-content>\n    </aside>\n  ",
                styles: ["\n    .ng-sidebar {\n      background-color: #fff;\n      overflow: auto;\n      pointer-events: auto;\n      position: fixed;\n      will-change: initial;\n      z-index: 99999999;\n    }\n\n      .ng-sidebar--left {\n        bottom: 0;\n        left: 0;\n        top: 0;\n      }\n\n      .ng-sidebar--right {\n        bottom: 0;\n        right: 0;\n        top: 0;\n      }\n\n      .ng-sidebar--top {\n        left: 0;\n        right: 0;\n        top: 0;\n      }\n\n      .ng-sidebar--bottom {\n        bottom: 0;\n        left: 0;\n        right: 0;\n      }\n\n    .ng-sidebar--inert {\n      pointer-events: none;\n      will-change: transform;\n    }\n\n    .ng-sidebar--animate.ng-sidebar {\n      -webkit-transition: -webkit-transform 0.3s cubic-bezier(0, 0, 0.3, 1);\n      transition: transform 0.3s cubic-bezier(0, 0, 0.3, 1);\n    }\n  "],
                changeDetection: core_1.ChangeDetectionStrategy.OnPush,
                encapsulation: core_1.ViewEncapsulation.None
            },] },
];
/** @nocollapse */
Sidebar.ctorParameters = function () { return [
    { type: sidebar_service_1.SidebarService, },
]; };
Sidebar.propDecorators = {
    'opened': [{ type: core_1.Input },],
    'openedChange': [{ type: core_1.Output },],
    'mode': [{ type: core_1.Input },],
    'dockedSize': [{ type: core_1.Input },],
    'position': [{ type: core_1.Input },],
    'animate': [{ type: core_1.Input },],
    'autoCollapseHeight': [{ type: core_1.Input },],
    'autoCollapseWidth': [{ type: core_1.Input },],
    'sidebarClass': [{ type: core_1.Input },],
    'ariaLabel': [{ type: core_1.Input },],
    'trapFocus': [{ type: core_1.Input },],
    'autoFocus': [{ type: core_1.Input },],
    'showBackdrop': [{ type: core_1.Input },],
    'closeOnClickBackdrop': [{ type: core_1.Input },],
    'closeOnClickOutside': [{ type: core_1.Input },],
    'keyClose': [{ type: core_1.Input },],
    'keyCode': [{ type: core_1.Input },],
    'onOpenStart': [{ type: core_1.Output },],
    'onOpened': [{ type: core_1.Output },],
    'onCloseStart': [{ type: core_1.Output },],
    'onClosed': [{ type: core_1.Output },],
    'onModeChange': [{ type: core_1.Output },],
    'onPositionChange': [{ type: core_1.Output },],
    '_onRerender': [{ type: core_1.Output },],
    '_elSidebar': [{ type: core_1.ViewChild, args: ['sidebar',] },],
};
exports.Sidebar = Sidebar;
